{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"\ud83d\udcf7 Capture the Moment","text":"<p>Welcome to the Capture the Moment project documentation. This project combines hardware and software to deliver a synchronized, real-time embedded solution.</p> <p></p>"},{"location":"#_1","title":"Home","text":""},{"location":"#sections","title":"\ud83d\udcda Sections","text":"<ul> <li>Hardware Overview: Explore the hardware architecture, components used, and circuit diagrams.</li> <li>Software Architecture: Dive into the firmware and software stack that powers the system.</li> <li>Implementation Details: Detailed explanation of configuration, timing, and system integration.</li> </ul>"},{"location":"#requirements","title":"\ud83d\udee0\ufe0f Requirements","text":"<ul> <li>STM32F4 Discovery board</li> <li>OV7670 Camera module</li> <li>LCD interface</li> <li>STM32CubeMX and STM32CubeIDE</li> <li>FreeRTOS</li> </ul>"},{"location":"#getting-started","title":"\ud83d\ude80 Getting Started","text":"<p>If you\u2019re new, start with the Hardware Overview and then move to Software. For implementation-specific notes and timing configuration, see Details.</p>"},{"location":"Details/","title":"Project Details","text":"<p>This project is proposed in accordance with the ELE529E Lecture at Istanbul Technical University.</p>"},{"location":"Details/#1-introduction","title":"1. Introduction","text":"<p>This project investigates real-time image processing using FreeRTOS on STM32F429I Discovery Board. The board features a built-in LCD and supports DCMI, making it ideal for interfacing with external cameras such as the OV7670. Applications of such embedded vision systems include industrial automation, surveillance, and portable diagnostics.</p>"},{"location":"Details/#2-system-architecture","title":"2. System Architecture","text":"<p>The system consists of a camera input, memory buffering using DMA, and LCD output. The architecture uses: - OV7670 camera module connected via DCMI and SCCB - DMA for efficient memory transfer - Frame buffer in RAM or SDRAM - SPI for driving the onboard LCD - FreeRTOS for managing concurrent tasks</p>"},{"location":"Details/#clock-configuration","title":"Clock Configuration","text":"<p>Here, in clock configuration HSE, an external clock source is configured and PLL scalers are to to it possible maximum values.  </p>"},{"location":"Details/#interfaces","title":"Interfaces","text":"<ul> <li>I2C1 is configured to set Registers of OV7670. </li> <li>SPI5 is configured to drive TFT LCD screen.  </li> </ul> <pre><code>flowchart TD\n  OV7670 --&gt;|DCMI + SSCB + DMA| RAM[Frame Buffer]\n  RAM --&gt;|SPI with ILI9341 LCD Driver| LCD\n  FreeRTOS --&gt;|Schedules| Tasks\n</code></pre>"},{"location":"Details/#3-rtos-based-task-scheduling","title":"3. RTOS-Based Task Scheduling","text":"<p>FreeRTOS tasks manage the operation as follows: - CameraTask: Configures and triggers DCMI DMA captures. - DisplayTask: Reads from frame buffer and updates LCD. - ProcessingTask (optional): Applies filters or transformations to the frame buffer.</p> <p>Each task uses <code>osDelay</code>, mutexes or semaphores to synchronize access to the shared buffer.</p>"},{"location":"Details/#4-dma-and-interrupt-based-frame-capture","title":"4. DMA and Interrupt-Based Frame Capture","text":"<p>DMA is configured to transfer camera data from DCMI to RAM[^7], triggered on frame complete interrupts. This minimizes CPU overhead.</p> <ul> <li>DCMI_IRQHandler: Signals a task via semaphore or event flag.</li> <li>DMA Interrupt: Ensures frame is fully transferred before display.</li> </ul>"},{"location":"Details/#5-camera-and-lcd-driver-integration","title":"5. Camera and LCD Driver Integration","text":"<p>The BSP (Board Support Package) is used to simplify interfacing: - <code>stm32f429i_discovery_lcd.c</code> for LCD display - Custom <code>OV7670.c</code> using HAL I2C for SCCB control - CubeMX-generated <code>MX_DMA_Init()</code> and <code>MX_DCMI_Init()</code> handle peripheral setup</p>"},{"location":"Details/#6-real-time-image-filtering","title":"6. Real-Time Image Filtering","text":"<p>A simple image processing pipeline can include: - Grayscale conversion - Laplacian and Gaussian filters - Region of Interest (ROI) detection - ROI-based alarm system for motion detection</p> <p>This is performed inside <code>FilteringTask</code>, and the result is written to a secondary buffer before being displayed.</p>"},{"location":"Details/#7-system-performance-and-evaluation","title":"7. System Performance and Evaluation","text":"<ul> <li>Frame Rate: Approx. 10-15 fps with basic processing</li> <li>Challenges:</li> <li>Synchronization between camera and display</li> <li>OV7670 clock and timing tuning</li> </ul>"},{"location":"Details/#8-conclusion-and-future-improvements","title":"8. Conclusion and Future Improvements","text":"<p>This project demonstrates a basic embedded vision pipeline using RTOS. Future extensions may include: - Performance optimization with SDRAM and cache - Integration with TouchGFX for UI - Object detection using CNNs (e.g., TinyML) - SD card logging or USB streaming</p>"},{"location":"Details/#9-references","title":"9. References","text":"<ol> <li>STM32F429I-DISC1 User Manual, STMicroelectronics  </li> <li>OV7670 Camera Module Datasheet  </li> <li>AN5020: STM32F4 DCMI Interface Application Note  </li> <li>FreeRTOS Documentation \u2013 https://freertos.org  </li> <li>STM32 HAL Reference Manual  </li> </ol>"},{"location":"Drivers/","title":"LCD Driver","text":"<p>The LCD driver provides low-level control over a TFT LCD screen connected via SPI. It includes GPIO and SPI initialization, display reset, and command/data communication using the ILI9341 controller protocol. </p> <p>Core functionalities include:</p> <ul> <li>Initialization sequence for power control, VCOM, gamma, and pixel format settings</li> <li>Drawing individual pixels or entire images to the display memory (GRAM)</li> <li>Screen rotation support in 4 directions</li> <li>IOCTL-style interface for issuing commands such as filling the screen, drawing pixels, or setting rotation</li> <li>Efficient image transfer using buffered SPI communication</li> </ul> <p>The driver abstracts all hardware control so that higher-level modules can render images or UI elements easily on the screen.</p>"},{"location":"Drivers/#camera-driver","title":"Camera Driver","text":"<p>The camera driver handles configuration and communication with the OV7670 camera module using I2C (SCCB) and DCMI (camera interface) with DMA support for efficient image capture.</p> <p>Main responsibilities:</p> <ul> <li>Hardware initialization for GPIOs, I2C, DCMI, and DMA</li> <li>Reset and setup of camera registers for QVGA resolution and RGB565 color mode</li> <li>Frame acquisition using DMA into memory</li> <li>Exposure and white balance configuration via OV7670 register presets</li> <li>Integration with the LCD driver to preview the camera output on-screen</li> </ul> <p>It offers an easy-to-use interface to start the camera and stream video frames into memory with minimal CPU overhead.</p>"},{"location":"Hardware/","title":"Project Hardware Details","text":"<ul> <li>STM32F429 Discovery Board</li> <li>Built-in Touchscreen LCD</li> <li>OV7670 Camera Module</li> </ul>"},{"location":"Hardware/#diagram","title":"Diagram","text":""},{"location":"Hardware/#result","title":"Result","text":""},{"location":"Hardware/#connections","title":"Connections","text":""},{"location":"Hardware/#dcmi-wiring","title":"DCMI Wiring","text":"uC Board OV7670 PB7 VSYNC PA4 HS PA6 PCLK PA8 XCLK PE6 D7 PE5 D6 PD3 D5 PE4 D4 PC9 D3 PC8 D2 PC7 D1 PC6 D0"},{"location":"Hardware/#sccb-wiring","title":"SCCB Wiring","text":"uC Board OV7670 PB8 SCL PB9 SDA"},{"location":"Hardware/#sdram-wiring","title":"SDRAM Wiring","text":"uC Board IS42S16400J PB6 SDNE1 PB5 SDCKE1 PC0 SDNWE PD15 D1 PD14 D0 PD10 D15 PD9 D14 PD8 D13 PD1 D3 PD0 D2 PE15 D12 PE14 D11 PE13 D10 PE12 D9 PE11 D8 PE10 D7 PE9 D6 PE8 D5 PE7 D4 PE1 NBL1 PE0 NBL0 PF15 A9 PF14 A8 PF13 A7 PF12 A6 PF11 SDNRAS PF5 A5 PF4 A4 PF3 A3 PF2 A2 PF1 A1 PF0 A0 PG15 SDNCAS PG8 SDCLK PG5 BA1 PG4 BA0 PG1 A11 PG0 A10"},{"location":"image_filtering_module/","title":"Image Filtering Module \u2013 Documentation","text":""},{"location":"image_filtering_module/#overview","title":"Overview","text":"<p>This module provides a set of image filtering functions for use in embedded systems, particularly in ARM Cortex-M based platforms using FreeRTOS. It includes support for:</p> <ul> <li>Grayscale conversion</li> <li>Laplacian and Gaussian filters</li> <li>Region of Interest (ROI) detection</li> <li>ROI-based alarm system for motion detection</li> </ul> <p>Memory-mapped SDRAM is used to store previous frames for differential processing. The module is optimized to work with RGB565 formatted images and leverages FreeRTOS time management for alarm timing.</p>"},{"location":"image_filtering_module/#dependencies","title":"Dependencies","text":"<pre><code>#include \"filter.h\"\n#include \"camera_drv.h\"\n#include \"cmsis_os.h\"\n</code></pre> <ul> <li><code>filter.h</code>: Filter type definitions and image size macros (e.g., <code>IMG_ROWS</code>, <code>IMG_COLUMNS</code>)</li> <li><code>camera_drv.h</code>: Camera-related constants and functions</li> <li><code>cmsis_os.h</code>: Required for FreeRTOS kernel tick functions</li> </ul>"},{"location":"image_filtering_module/#constants","title":"Constants","text":""},{"location":"image_filtering_module/#sdram-memory-mapping","title":"SDRAM Memory Mapping","text":"<pre><code>#define SDRAM_BANK_ADDR     ((uint32_t)0xD0000000)\n#define PREVIOUS_FRAME_ADDR (SDRAM_BANK_ADDR + 0x100000)\n</code></pre> <ul> <li>Used to store the previous frame for ROI comparison.</li> <li>Ensures non-volatile temporary storage across frames.</li> </ul>"},{"location":"image_filtering_module/#kernel-definitions","title":"Kernel Definitions","text":"<pre><code>const int laplacian_kernel[3][3] = { {-1,-1,-1}, {-1,8,-1}, {-1,-1,-1} };\nconst int gaussian_kernel[3][3] = { {1,2,1}, {2,4,2}, {1,2,1} };\nconst int gaussian_factor = 16;\n</code></pre> <ul> <li>3x3 convolution kernels for edge detection and noise reduction.</li> </ul>"},{"location":"image_filtering_module/#filter-types-filtertype","title":"Filter Types (<code>FilterType</code>)","text":"<p>This enum (from <code>filter.h</code>) defines the available image filters: - <code>FILTER_NONE</code>: No filtering - <code>FILTER_GRAYSCALE</code>: Converts RGB565 to grayscale - <code>FILTER_LAPLACIAN</code>: Applies a Laplacian filter - <code>FILTER_GAUSSIAN</code>: Applies a Gaussian blur - <code>FILTER_ROI</code>: Highlights changed regions using previous frame - <code>FILTER_ROI_CENTER_ALARM</code>: Triggers alarm on central movement</p>"},{"location":"image_filtering_module/#function-descriptions","title":"Function Descriptions","text":""},{"location":"image_filtering_module/#void-applykernel3x3_window","title":"<code>void applyKernel3x3_window(...)</code>","text":"<p>Applies a 3x3 kernel to a grayscale window.</p> <ul> <li>Inputs:</li> <li><code>window[3][3]</code>: Grayscale values</li> <li><code>kernel[3][3]</code>: Convolution kernel</li> <li><code>kernel_factor</code>: Normalization factor</li> <li>Output:</li> <li><code>*result</code>: Resulting pixel value after kernel application</li> </ul>"},{"location":"image_filtering_module/#void-applyfiltertoimage","title":"<code>void applyFilterToImage(...)</code>","text":"<p>Applies a specified filter line-by-line with limited memory usage.</p> <ul> <li>Optimized for memory-constrained environments</li> <li>Maintains 3-line rolling buffer for kernel filtering</li> <li>Skips kernel on the first two lines (fills black)</li> </ul>"},{"location":"image_filtering_module/#void-applyfiltertoimagefull","title":"<code>void applyFilterToImageFull(...)</code>","text":"<p>Applies a specified filter to the entire image frame.</p>"},{"location":"image_filtering_module/#filter_none","title":"<code>FILTER_NONE</code>:","text":"<ul> <li>Simple copy of <code>input_image</code> to <code>output_image</code></li> </ul>"},{"location":"image_filtering_module/#filter_grayscale","title":"<code>FILTER_GRAYSCALE</code>:","text":"<ul> <li>Converts each pixel to grayscale using luminance approximation:   <code>c   gray = (r * 299 + g * 587 + b * 114) / 1000;</code></li> </ul>"},{"location":"image_filtering_module/#filter_laplacian-filter_gaussian","title":"<code>FILTER_LAPLACIAN</code> / <code>FILTER_GAUSSIAN</code>:","text":"<ul> <li>Applies respective 3x3 kernel across the image (ignores edges)</li> </ul>"},{"location":"image_filtering_module/#filter_roi","title":"<code>FILTER_ROI</code>:","text":"<ul> <li>Compares current frame with stored <code>previous_frame</code></li> <li>Highlights changed 5x5 regions if grayscale difference exceeds <code>ROI_TH</code></li> <li>Region size: <code>ROI_WIDTH</code>, <code>ROI_HEIGHT</code></li> <li>Retains only moving parts</li> </ul>"},{"location":"image_filtering_module/#filter_roi_center_alarm","title":"<code>FILTER_ROI_CENTER_ALARM</code>:","text":"<ul> <li>Monitors central 50x50 pixel area</li> <li>Triggers red-screen alarm (<code>ALARM_COLOR</code>, RGB565) if motion exceeds <code>CENTER_ROI_TH</code></li> <li>Alarm persists for <code>ALARM_DURATION_MS</code></li> </ul>"},{"location":"image_filtering_module/#alarm-logic","title":"Alarm Logic","text":""},{"location":"image_filtering_module/#global-variables","title":"Global Variables","text":"<pre><code>static uint8_t first_frame = 1;\nstatic uint8_t first_frame_center = 1;\nstatic uint32_t alarm_start_time = 0;\nstatic uint8_t alarm_active = 0;\n</code></pre> <ul> <li>Track whether the frame is the first processed frame</li> <li>Manage alarm state and duration</li> </ul>"},{"location":"image_filtering_module/#alarm-workflow","title":"Alarm Workflow","text":"<ol> <li>If the center ROI detects motion beyond a threshold:</li> <li>All pixels turn red (<code>ALARM_COLOR</code>)</li> <li>Alarm stays active for <code>ALARM_DURATION_MS</code></li> <li>If alarm is still active:</li> <li>The central area remains red regardless of motion</li> <li>After duration expires:</li> <li>Frame returns to normal processing</li> </ol>"},{"location":"image_filtering_module/#rgb565-grayscale-conversion","title":"RGB565 \u2194 Grayscale Conversion","text":""},{"location":"image_filtering_module/#rgb565-to-grayscale","title":"RGB565 to Grayscale","text":"<pre><code>r = (rgb &gt;&gt; 11) &amp; 0x1F;\ng = (rgb &gt;&gt; 5) &amp; 0x3F;\nb = rgb &amp; 0x1F;\ngray = (r * 299 + g * 587 + b * 114) / 1000;\n</code></pre>"},{"location":"image_filtering_module/#grayscale-to-rgb565","title":"Grayscale to RGB565","text":"<pre><code>r5 = (gray * 31) / 255;\ng6 = (gray * 63) / 255;\nb5 = (gray * 31) / 255;\nrgb565 = (r5 &lt;&lt; 11) | (g6 &lt;&lt; 5) | b5;\n</code></pre>"},{"location":"image_filtering_module/#optimization-notes","title":"Optimization Notes","text":"<ul> <li>Uses 3-line rolling buffer for memory efficiency in <code>applyFilterToImage</code></li> <li>Skips processing of edge pixels to avoid out-of-bounds errors</li> <li>SDRAM provides persistent frame memory across FreeRTOS tasks</li> <li>Central ROI logic optimized with early exit (<code>break</code>) for faster decision making</li> </ul>"},{"location":"image_filtering_module/#use-cases","title":"Use Cases","text":"<ul> <li>Embedded image recognition pipelines</li> <li>Real-time surveillance systems (motion detection)</li> <li>Memory-constrained MCU-based image processors</li> </ul>"},{"location":"image_filtering_module/#todo-improvements","title":"TODO / Improvements","text":"<ul> <li>Parameterize ROI sizes and thresholds dynamically</li> <li>Extend filter support (e.g., Sobel, Median)</li> <li>Add interrupt-based frame update handling</li> </ul>"}]}