{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"\ud83d\udcf7 Capture the Moment","text":"<p>Welcome to the Capture the Moment project documentation. This project combines hardware and software to deliver a synchronized, real-time embedded solution.</p> <p></p>"},{"location":"#_1","title":"Home","text":""},{"location":"#sections","title":"\ud83d\udcda Sections","text":"<ul> <li>Hardware Overview: Explore the hardware architecture, components used, and circuit diagrams.</li> <li>Software Architecture: Dive into the firmware and software stack that powers the system.</li> <li>Implementation Details: Detailed explanation of configuration, timing, and system integration.</li> </ul>"},{"location":"#requirements","title":"\ud83d\udee0\ufe0f Requirements","text":"<ul> <li>STM32F4 Discovery board</li> <li>OV7670 Camera module</li> <li>LCD interface</li> <li>STM32CubeMX and STM32CubeIDE</li> <li>FreeRTOS</li> </ul>"},{"location":"#getting-started","title":"\ud83d\ude80 Getting Started","text":"<p>If you\u2019re new, start with the Hardware Overview and then move to Software. For implementation-specific notes and timing configuration, see Details.</p>"},{"location":"Details/","title":"Project Details","text":"<p>This project is proposed in accordance with the ELE529E Lecture at Istanbul Technical University.</p>"},{"location":"Details/#1-introduction","title":"1. Introduction","text":"<p>This project investigates real-time image processing using FreeRTOS on STM32F429I Discovery Board. The board features a built-in LCD and supports DCMI, making it ideal for interfacing with external cameras such as the OV7670. Applications of such embedded vision systems include industrial automation, surveillance, and portable diagnostics.</p>"},{"location":"Details/#2-system-architecture","title":"2. System Architecture","text":"<p>The system consists of a camera input, memory buffering using DMA, and LCD output. The architecture uses: - OV7670 camera module connected via DCMI and SCCB - DMA for efficient memory transfer - Frame buffer in RAM or SDRAM - SPI for driving the onboard LCD - FreeRTOS for managing concurrent tasks</p>"},{"location":"Details/#clock-configuration","title":"Clock Configuration","text":"<p>Here, in the clock configuration, HSE (external oscillator) is enabled and PLL scalers are set to their maximum allowable values.</p> <p></p>"},{"location":"Details/#interfaces","title":"Interfaces","text":"<ul> <li>I2C1 is configured to set Registers of OV7670. </li> <li>SPI5 is configured to drive TFT LCD screen.  </li> </ul> <pre><code>flowchart TD\n  OV7670 --&gt;|DCMI + SSCB + DMA| RAM[Frame Buffer]\n  RAM --&gt;|SPI with ILI9341 LCD Driver| LCD\n  FreeRTOS --&gt;|Schedules| Tasks\n</code></pre>"},{"location":"Details/#3-rtos-based-task-scheduling","title":"3. RTOS-Based Task Scheduling","text":"<p>FreeRTOS tasks manage the operation as follows:</p> <ul> <li>CameraTask: Configures and triggers DCMI DMA captures.</li> <li>DisplayTask: Reads from frame buffer and updates LCD.</li> <li>ProcessingTask (optional): Applies filters or transformations to the frame buffer.</li> </ul> <p>Each task uses <code>osDelay</code>, mutexes or semaphores to synchronize access to the shared buffer.</p>"},{"location":"Details/#4-dma-and-interrupt-based-frame-capture","title":"4. DMA and Interrupt-Based Frame Capture","text":"<p>DMA is configured to transfer camera data from DCMI to RAM, triggered on frame complete interrupts. This minimizes CPU overhead.</p> <ul> <li>DCMI_IRQHandler: Signals a task via semaphore or event flag.</li> <li>DMA Interrupt: Ensures frame is fully transferred before display.</li> </ul>"},{"location":"Details/#5-camera-and-lcd-driver-integration","title":"5. Camera and LCD Driver Integration","text":"<p>The BSP (Board Support Package) is used to simplify interfacing:</p> <ul> <li><code>stm32f429i_discovery_lcd.c</code> for LCD display</li> <li>Custom <code>OV7670.c</code> using HAL I2C for SCCB control</li> <li>CubeMX-generated <code>MX_DMA_Init()</code> and <code>MX_DCMI_Init()</code> handle peripheral setup</li> </ul>"},{"location":"Details/#6-real-time-image-filtering","title":"6. Real-Time Image Filtering","text":"<p>A simple image processing pipeline can include:</p> <ul> <li>Grayscale conversion</li> <li>Laplacian and Gaussian filters</li> <li>Region of Interest (ROI) detection</li> <li>ROI-based alarm system for motion detection</li> </ul> <p>This is performed inside <code>FilteringTask</code>, and the result is written to a secondary buffer before being displayed.</p>"},{"location":"Details/#7-system-performance-and-evaluation","title":"7. System Performance and Evaluation","text":"<p>Frame Rate: </p> <ul> <li>Approx. 10-15 fps with basic processing</li> </ul> <p>Challenges:</p> <ul> <li>Synchronization between camera and display</li> <li>OV7670 clock and timing tuning</li> </ul>"},{"location":"Details/#8-conclusion-and-future-improvements","title":"8. Conclusion and Future Improvements","text":"<p>This project demonstrates a basic embedded vision pipeline using RTOS. Future extensions may include:</p> <ul> <li>Performance optimization with SDRAM and cache</li> <li>Integration with TouchGFX for UI</li> <li>Object detection using CNNs (e.g., TinyML)</li> <li>SD card logging or USB streaming</li> </ul>"},{"location":"Drivers/","title":"OV7670 Camera Driver Documentation","text":""},{"location":"Drivers/#overview","title":"Overview","text":"<p>This driver provides initialization and control routines for the OV7670 camera module using STM32F4 microcontrollers. It configures the camera through I2C (SCCB protocol), sets up DCMI for image capture, and manages DMA transfers for efficient data handling.</p>"},{"location":"Drivers/#features","title":"Features","text":"<ul> <li>I2C initialization and communication with OV7670 camera registers</li> <li>DCMI peripheral setup for image data capture</li> <li>DMA configuration for circular buffering of camera data</li> <li>Clock generation for camera (XCLK) using MCU MCO output</li> <li>Camera register initialization with default settings for QVGA RGB565 output format</li> </ul>"},{"location":"Drivers/#supported-hardware-pins","title":"Supported Hardware Pins","text":"MCU Pin Camera Signal PB8 SIOC (I2C Clock) PB9 SIOD (I2C Data) PB7 VSYNC PA4 HS PA6 PCLK PA8 XCLK PE6 D7 PE5 D6 PD3 D5 PE4 D4 PC9 D3 PC8 D2 PC7 D1 PC6 D0"},{"location":"Drivers/#api-reference","title":"API Reference","text":""},{"location":"Drivers/#te_camera_error_codes-camera_openvoid","title":"te_CAMERA_ERROR_CODES Camera_Open(void)","text":"<p>Initializes all required peripherals and configures the OV7670 camera module.</p> <p>Returns: </p> <p>E_CAMERA_ERR_NONE on success, otherwise an error code indicating the failure reason.</p>"},{"location":"Drivers/#enumerations","title":"Enumerations","text":""},{"location":"Drivers/#te_camera_error_codes","title":"te_CAMERA_ERROR_CODES","text":"Enum Description E_CAMERA_ERR_NONE No error E_CAMERA_ERR_I2C_INIT I2C initialization failed E_CAMERA_ERR_DCMI_INIT DCMI initialization failed E_CAMERA_ERR_DMA_INIT DMA initialization failed E_CAMERA_ERR_CAMERA_INIT Camera register init failed"},{"location":"Drivers/#internal-functions-static","title":"Internal Functions (Static)","text":"<p>These functions are not exposed publicly but form the internal implementation of the driver:</p> <ul> <li> <p>static te_CAMERA_ERROR_CODES Camera_Init(void)   Writes default configuration registers to the OV7670 via I2C.</p> </li> <li> <p>static void Camera_GPIO_Init(void)   Configures GPIO pins for camera data, control signals, and I2C.</p> </li> <li> <p>static te_CAMERA_ERROR_CODES Camera_DCMI_Init(void)   Initializes the DCMI peripheral with proper parameters for OV7670 data capture.</p> </li> <li> <p>static void Camera_XCLK_Init(void)   Sets up the MCU clock output (MCO) to provide the external clock (XCLK) signal to the camera.</p> </li> <li> <p>static te_CAMERA_ERROR_CODES Camera_DMA_Init(void)   Configures the DMA stream for circular buffer mode linked to DCMI.</p> </li> <li> <p>static te_CAMERA_ERROR_CODES Camera_I2C_Init(void)   Sets up the I2C peripheral for SCCB communication with OV7670.</p> </li> </ul>"},{"location":"Drivers/#data-structures-and-definitions","title":"Data Structures and Definitions","text":"Macro / Constant Description OV7670_REG_NUM Number of camera registers configured (122) OV7670_WRITE_ADDR I2C write address for OV7670 (0x42) IMG_ROWS Image height in pixels (320) IMG_COLUMNS Image width in pixels (240)"},{"location":"Drivers/#how-it-works","title":"How It Works","text":"<ol> <li>Camera_Open() is called to start initialization.</li> <li>I2C peripheral is configured for communication.</li> <li>DCMI peripheral is set up to capture data synchronized with camera signals.</li> <li>DMA is configured to transfer image data continuously to memory.</li> <li>Camera external clock (XCLK) is generated using MCU's MCO pin.</li> <li>OV7670 registers are written to via I2C to configure resolution, color format, and other camera parameters.</li> <li>After successful initialization, the camera is ready to capture images.</li> </ol>"},{"location":"Drivers/#usage-example","title":"Usage Example","text":"<pre><code>#include \"camera_drv.h\"\n\nint main(void) {\n    // HAL initialization here\n\n    te_CAMERA_ERROR_CODES status = Camera_Open();\n    if (status != E_CAMERA_ERR_NONE) {\n        // Handle error\n    }\n\n    // Start DCMI capture, DMA, etc.\n}\n</code></pre>"},{"location":"Drivers/#lcd-driver-documentation","title":"LCD Driver Documentation","text":"<p>This document describes the functions of the SPI-based 320x240 LCD driver for STM32F4.</p>"},{"location":"Drivers/#overview_1","title":"Overview","text":"<ul> <li>The LCD is controlled via SPI5 interface.</li> <li>GPIO pins are configured for LCD control and SPI communication.</li> <li>Basic LCD control functions and a generic IOCTL interface are provided.</li> </ul>"},{"location":"Drivers/#functions","title":"Functions","text":""},{"location":"Drivers/#te_lcd_error_codes-lcd_openvoid-vpparam","title":"te_LCD_ERROR_CODES LCD_Open(void* vpParam)","text":"<p>Description: </p> <p>Initializes the LCD driver. Configures GPIO and SPI peripherals, resets the LCD, and performs initial setup.</p> <p>Parameters: </p> <ul> <li>vpParam: Generic parameter pointer (currently unused).</li> </ul> <p>Returns: </p> <ul> <li>E_LCD_ERR_NONE: Initialization successful.  </li> <li>E_LCD_ERR_SPI_INIT: SPI initialization failed.</li> </ul>"},{"location":"Drivers/#te_lcd_error_codes-lcd_ioctlte_lcd_ioctl_commands-ecommand-void-vpparam","title":"te_LCD_ERROR_CODES LCD_Ioctl(te_LCD_IOCTL_COMMANDS eCommand, void * vpParam)","text":"<p>Description: </p> <p>General control interface for the LCD. Supports operations like drawing a pixel, filling the screen, displaying images, rotating the screen, etc.</p> <p>Parameters: </p> <ul> <li>eCommand: The control command to execute (e.g., E_LCD_IOCTL_DRAW_PIXEL).  </li> <li>vpParam: Pointer to the data or parameters required by the command.</li> </ul> <p>Returns: </p> <ul> <li>E_LCD_ERR_NONE: Operation successful.  </li> <li>E_LCD_ERR_WRONG_IOCTL_CMD: Unsupported command.</li> </ul>"},{"location":"Drivers/#te_lcd_error_codes-lcd_writeconst-void-pvbuffer-const-uint32_t-xbytes","title":"te_LCD_ERROR_CODES LCD_Write(const void *pvBuffer, const uint32_t xBytes)","text":"<p>Description: </p> <p>Writes pixel color data to the currently active window on the LCD.</p> <p>Parameters:</p> <ul> <li>pvBuffer: Pointer to the color data buffer (of type ts_LCD_WR_TYPE).  </li> <li>xBytes: Number of bytes to write (not used in current implementation).</li> </ul> <p>Returns: </p> <ul> <li>E_LCD_ERR_NONE: Write operation successful.</li> </ul>"},{"location":"Drivers/#te_lcd_error_codes-lcd_closevoid-vpparam","title":"te_LCD_ERROR_CODES LCD_Close(void* vpParam)","text":"<p>Description: </p> <p>Closes the LCD driver, turns off the display, and stops SPI communication.</p> <p>Parameters: </p> <ul> <li>vpParam: Generic parameter pointer (currently unused).</li> </ul> <p>Returns: </p> <ul> <li>E_LCD_ERR_NONE: Successfully closed.</li> </ul>"},{"location":"Drivers/#static-te_lcd_error_codes-lcd_gpio_initvoid","title":"static te_LCD_ERROR_CODES LCD_GPIO_Init(void)","text":"<p>Description: </p> <p>Configures GPIO pins and clocks required for the LCD and SPI interface.</p> <p>Returns: </p> <ul> <li>E_LCD_ERR_NONE: GPIO initialization successful.</li> </ul>"},{"location":"Drivers/#static-te_lcd_error_codes-lcd_spi_initvoid","title":"static te_LCD_ERROR_CODES LCD_SPI_Init(void)","text":"<p>Description: </p> <p>Initializes SPI5 peripheral as a master with the necessary settings for LCD communication.</p> <p>Returns: </p> <ul> <li>E_LCD_ERR_NONE: SPI initialization successful.  </li> <li>E_LCD_ERR_SPI_INIT: SPI initialization failed.</li> </ul>"},{"location":"Drivers/#void-lcd_resetvoid","title":"void LCD_Reset(void)","text":"<p>Description: Performs a hardware reset on the LCD by toggling the reset pin.</p>"},{"location":"Drivers/#error-codes-te_lcd_error_codes","title":"Error Codes (te_LCD_ERROR_CODES)","text":"Code Meaning E_LCD_ERR_NONE Operation successful E_LCD_ERR_SPI_INIT SPI initialization error E_LCD_ERR_WRONG_IOCTL_CMD Invalid IOCTL command"},{"location":"Drivers/#usage-example_1","title":"Usage Example","text":"<pre><code>if (LCD_Open(NULL) != E_LCD_ERR_NONE) {\n    // Handle error\n}\n\nts_LCD_DRAW_PIXEL pixel = {x, y, color};\nLCD_Ioctl(E_LCD_IOCTL_DRAW_PIXEL, &amp;pixel);\n\nLCD_Close(NULL);\n</code></pre>"},{"location":"Hardware/","title":"Project Hardware Details","text":"<ul> <li>STM32F429 Discovery Board</li> <li>Built-in Touchscreen LCD</li> <li>OV7670 Camera Module</li> </ul>"},{"location":"Hardware/#diagram","title":"Diagram","text":""},{"location":"Hardware/#result","title":"Result","text":""},{"location":"Hardware/#connections","title":"Connections","text":""},{"location":"Hardware/#dcmi-wiring","title":"DCMI Wiring","text":"uC Board OV7670 PB7 VSYNC PA4 HS PA6 PCLK PA8 XCLK PE6 D7 PE5 D6 PD3 D5 PE4 D4 PC9 D3 PC8 D2 PC7 D1 PC6 D0"},{"location":"Hardware/#sccb-wiring","title":"SCCB Wiring","text":"uC Board OV7670 PB8 SCL PB9 SDA"},{"location":"Hardware/#sdram-wiring","title":"SDRAM Wiring","text":"uC Board IS42S16400J PB6 SDNE1 PB5 SDCKE1 PC0 SDNWE PD15 D1 PD14 D0 PD10 D15 PD9 D14 PD8 D13 PD1 D3 PD0 D2 PE15 D12 PE14 D11 PE13 D10 PE12 D9 PE11 D8 PE10 D7 PE9 D6 PE8 D5 PE7 D4 PE1 NBL1 PE0 NBL0 PF15 A9 PF14 A8 PF13 A7 PF12 A6 PF11 SDNRAS PF5 A5 PF4 A4 PF3 A3 PF2 A2 PF1 A1 PF0 A0 PG15 SDNCAS PG8 SDCLK PG5 BA1 PG4 BA0 PG1 A11 PG0 A10"},{"location":"References/","title":"References","text":"<ol> <li>STM32F429I-DISC1 User Manual, STMicroelectronics  </li> <li>OV7670 Camera Module Datasheet  </li> <li>AN5020: STM32F4 DCMI Interface Application Note  </li> <li>FreeRTOS Documentation \u2013 https://freertos.org  </li> <li>STM32 HAL Reference Manual  </li> <li>ILI9341 Specifications</li> </ol>"},{"location":"image_filtering_module/","title":"Image Filtering Module \u2013 Documentation","text":""},{"location":"image_filtering_module/#overview","title":"Overview","text":"<p>This module provides a set of image filtering functions for use in embedded systems, particularly in ARM Cortex-M based platforms using FreeRTOS. It includes support for:</p> <ul> <li>Grayscale conversion</li> <li>Laplacian and Gaussian filters</li> <li>Region of Interest (ROI) detection</li> <li>ROI-based alarm system for motion detection</li> </ul> <p>Memory-mapped SDRAM is used to store previous frames for differential processing. The module is optimized to work with RGB565 formatted images and leverages FreeRTOS time management for alarm timing.</p>"},{"location":"image_filtering_module/#dependencies","title":"Dependencies","text":"<pre><code>#include \"filter.h\"\n#include \"camera_drv.h\"\n#include \"cmsis_os.h\"\n</code></pre> <ul> <li><code>filter.h</code>: Filter type definitions and image size macros (e.g., <code>IMG_ROWS</code>, <code>IMG_COLUMNS</code>)</li> <li><code>camera_drv.h</code>: Camera-related constants and functions</li> <li><code>cmsis_os.h</code>: Required for FreeRTOS kernel tick functions</li> </ul>"},{"location":"image_filtering_module/#constants","title":"Constants","text":""},{"location":"image_filtering_module/#sdram-memory-mapping","title":"SDRAM Memory Mapping","text":"<pre><code>#define SDRAM_BANK_ADDR     ((uint32_t)0xD0000000)\n#define PREVIOUS_FRAME_ADDR (SDRAM_BANK_ADDR + 0x100000)\n</code></pre> <ul> <li>Used to store the previous frame for ROI comparison.</li> <li>Ensures non-volatile temporary storage across frames.</li> </ul>"},{"location":"image_filtering_module/#kernel-definitions","title":"Kernel Definitions","text":"<pre><code>const int laplacian_kernel[3][3] = { {-1,-1,-1}, {-1,8,-1}, {-1,-1,-1} };\nconst int gaussian_kernel[3][3] = { {1,2,1}, {2,4,2}, {1,2,1} };\nconst int gaussian_factor = 16;\n</code></pre> <ul> <li>3x3 convolution kernels for edge detection and noise reduction.</li> </ul>"},{"location":"image_filtering_module/#filter-types-filtertype","title":"Filter Types (<code>FilterType</code>)","text":"<p>This enum (from <code>filter.h</code>) defines the available image filters: - <code>FILTER_NONE</code>: No filtering - <code>FILTER_GRAYSCALE</code>: Converts RGB565 to grayscale - <code>FILTER_LAPLACIAN</code>: Applies a Laplacian filter - <code>FILTER_GAUSSIAN</code>: Applies a Gaussian blur - <code>FILTER_ROI</code>: Highlights changed regions using previous frame - <code>FILTER_ROI_CENTER_ALARM</code>: Triggers alarm on central movement</p>"},{"location":"image_filtering_module/#function-descriptions","title":"Function Descriptions","text":""},{"location":"image_filtering_module/#void-applykernel3x3_window","title":"<code>void applyKernel3x3_window(...)</code>","text":"<p>Applies a 3x3 kernel to a grayscale window.</p> <ul> <li>Inputs:</li> <li><code>window[3][3]</code>: Grayscale values</li> <li><code>kernel[3][3]</code>: Convolution kernel</li> <li><code>kernel_factor</code>: Normalization factor</li> <li>Output:</li> <li><code>*result</code>: Resulting pixel value after kernel application</li> </ul>"},{"location":"image_filtering_module/#void-applyfiltertoimage","title":"<code>void applyFilterToImage(...)</code>","text":"<p>Applies a specified filter line-by-line with limited memory usage.</p> <ul> <li>Optimized for memory-constrained environments</li> <li>Maintains 3-line rolling buffer for kernel filtering</li> <li>Skips kernel on the first two lines (fills black)</li> </ul>"},{"location":"image_filtering_module/#void-applyfiltertoimagefull","title":"<code>void applyFilterToImageFull(...)</code>","text":"<p>Applies a specified filter to the entire image frame.</p>"},{"location":"image_filtering_module/#filter_none","title":"<code>FILTER_NONE</code>:","text":"<ul> <li>Simple copy of <code>input_image</code> to <code>output_image</code></li> </ul>"},{"location":"image_filtering_module/#filter_grayscale","title":"<code>FILTER_GRAYSCALE</code>:","text":"<ul> <li>Converts each pixel to grayscale using luminance approximation:   <code>c   gray = (r * 299 + g * 587 + b * 114) / 1000;</code></li> </ul>"},{"location":"image_filtering_module/#filter_laplacian-filter_gaussian","title":"<code>FILTER_LAPLACIAN</code> / <code>FILTER_GAUSSIAN</code>:","text":"<ul> <li>Applies respective 3x3 kernel across the image (ignores edges)</li> </ul>"},{"location":"image_filtering_module/#filter_roi","title":"<code>FILTER_ROI</code>:","text":"<ul> <li>Compares current frame with stored <code>previous_frame</code></li> <li>Highlights changed 5x5 regions if grayscale difference exceeds <code>ROI_TH</code></li> <li>Region size: <code>ROI_WIDTH</code>, <code>ROI_HEIGHT</code></li> <li>Retains only moving parts</li> </ul>"},{"location":"image_filtering_module/#filter_roi_center_alarm","title":"<code>FILTER_ROI_CENTER_ALARM</code>:","text":"<ul> <li>Monitors central 50x50 pixel area</li> <li>Triggers red-screen alarm (<code>ALARM_COLOR</code>, RGB565) if motion exceeds <code>CENTER_ROI_TH</code></li> <li>Alarm persists for <code>ALARM_DURATION_MS</code></li> </ul>"},{"location":"image_filtering_module/#alarm-logic","title":"Alarm Logic","text":""},{"location":"image_filtering_module/#global-variables","title":"Global Variables","text":"<pre><code>static uint8_t first_frame = 1;\nstatic uint8_t first_frame_center = 1;\nstatic uint32_t alarm_start_time = 0;\nstatic uint8_t alarm_active = 0;\n</code></pre> <ul> <li>Track whether the frame is the first processed frame</li> <li>Manage alarm state and duration</li> </ul>"},{"location":"image_filtering_module/#alarm-workflow","title":"Alarm Workflow","text":"<ol> <li>If the center ROI detects motion beyond a threshold:</li> <li>All pixels turn red (<code>ALARM_COLOR</code>)</li> <li>Alarm stays active for <code>ALARM_DURATION_MS</code></li> <li>If alarm is still active:</li> <li>The central area remains red regardless of motion</li> <li>After duration expires:</li> <li>Frame returns to normal processing</li> </ol>"},{"location":"image_filtering_module/#rgb565-grayscale-conversion","title":"RGB565 \u2194 Grayscale Conversion","text":""},{"location":"image_filtering_module/#rgb565-to-grayscale","title":"RGB565 to Grayscale","text":"<pre><code>r = (rgb &gt;&gt; 11) &amp; 0x1F;\ng = (rgb &gt;&gt; 5) &amp; 0x3F;\nb = rgb &amp; 0x1F;\ngray = (r * 299 + g * 587 + b * 114) / 1000;\n</code></pre>"},{"location":"image_filtering_module/#grayscale-to-rgb565","title":"Grayscale to RGB565","text":"<pre><code>r5 = (gray * 31) / 255;\ng6 = (gray * 63) / 255;\nb5 = (gray * 31) / 255;\nrgb565 = (r5 &lt;&lt; 11) | (g6 &lt;&lt; 5) | b5;\n</code></pre>"},{"location":"image_filtering_module/#optimization-notes","title":"Optimization Notes","text":"<ul> <li>Uses 3-line rolling buffer for memory efficiency in <code>applyFilterToImage</code></li> <li>Skips processing of edge pixels to avoid out-of-bounds errors</li> <li>SDRAM provides persistent frame memory across FreeRTOS tasks</li> <li>Central ROI logic optimized with early exit (<code>break</code>) for faster decision making</li> </ul>"},{"location":"image_filtering_module/#use-cases","title":"Use Cases","text":"<ul> <li>Embedded image recognition pipelines</li> <li>Real-time surveillance systems (motion detection)</li> <li>Memory-constrained MCU-based image processors</li> </ul>"},{"location":"image_filtering_module/#todo-improvements","title":"TODO / Improvements","text":"<ul> <li>Parameterize ROI sizes and thresholds dynamically</li> <li>Extend filter support (e.g., Sobel, Median)</li> <li>Add interrupt-based frame update handling</li> </ul>"}]}